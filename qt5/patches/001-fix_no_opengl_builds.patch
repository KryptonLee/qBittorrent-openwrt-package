--- a/qtlocation/src/location/configure.json
+++ b/qtlocation/src/location/configure.json
@@ -9,6 +9,7 @@
             "label": "Qt.labs.location experimental QML plugin",
             "purpose": "Provides experimental QtLocation QML types",
             "section": "Location",
+	    "condition": "config.opengl",
             "output": [ "privateFeature" ]
         },
         "geoservices_osm": {
--- a/qtlocation/src/location/declarativemaps/qdeclarativecirclemapitem.cpp
+++ b/qtlocation/src/location/declarativemaps/qdeclarativecirclemapitem.cpp
@@ -446,6 +446,7 @@ void QDeclarativeCircleMapItem::updatePo
 */
 void QDeclarativeCircleMapItem::possiblySwitchBackend(const QGeoCoordinate &oldCenter, qreal oldRadius, const QGeoCoordinate &newCenter, qreal newRadius)
 {
+#if QT_CONFIG(opengl)
     if (m_backend != QDeclarativeCircleMapItem::OpenGL)
         return;
 
@@ -459,6 +460,9 @@ void QDeclarativeCircleMapItem::possibly
         QScopedPointer<QDeclarativeCircleMapItemPrivate> d(static_cast<QDeclarativeCircleMapItemPrivate *>(new QDeclarativeCircleMapItemPrivateOpenGL(*this)));
         m_d.swap(d);
     }
+#else
+    return;
+#endif
 }
 
 /*!
@@ -534,9 +538,17 @@ void QDeclarativeCircleMapItem::setBacke
     if (b == m_backend)
         return;
     m_backend = b;
-    QScopedPointer<QDeclarativeCircleMapItemPrivate> d((m_backend == Software)
-                                                        ? static_cast<QDeclarativeCircleMapItemPrivate *>(new QDeclarativeCircleMapItemPrivateCPU(*this))
-                                                        : static_cast<QDeclarativeCircleMapItemPrivate * >(new QDeclarativeCircleMapItemPrivateOpenGL(*this)));
+    QScopedPointer<QDeclarativeCircleMapItemPrivate> d(
+            (m_backend == Software) ? static_cast<QDeclarativeCircleMapItemPrivate *>(
+		    new QDeclarativeCircleMapItemPrivateCPU(*this))
+#if QT_CONFIG(opengl)
+	                            : static_cast<QDeclarativeCircleMapItemPrivate *>(
+                                            new QDeclarativeCircleMapItemPrivateOpenGL(*this)));
+#else
+                                    : nullptr);
+    qFatal("Requested non software rendering backend, but source code is compiled wihtout opengl "
+           "support");
+#endif
     m_d.swap(d);
     m_d->onGeoGeometryChanged();
     emit backendChanged();
@@ -565,7 +577,9 @@ QDeclarativeCircleMapItemPrivate::~QDecl
 
 QDeclarativeCircleMapItemPrivateCPU::~QDeclarativeCircleMapItemPrivateCPU() {}
 
+#if QT_CONFIG(opengl)
 QDeclarativeCircleMapItemPrivateOpenGL::~QDeclarativeCircleMapItemPrivateOpenGL() {}
+#endif
 
 bool QDeclarativeCircleMapItemPrivate::preserveCircleGeometry (QList<QDoubleVector2D> &path,
                                     const QGeoCoordinate &center, qreal distance, const QGeoProjectionWebMercator &p)
--- a/qtlocation/src/location/declarativemaps/qdeclarativecirclemapitem_p_p.h
+++ b/qtlocation/src/location/declarativemaps/qdeclarativecirclemapitem_p_p.h
@@ -275,6 +275,7 @@ public:
     MapPolygonNode *m_node = nullptr;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativeCircleMapItemPrivateOpenGL: public QDeclarativeCircleMapItemPrivate
 {
 public:
@@ -443,6 +444,7 @@ public:
     MapPolygonNodeGL *m_node = nullptr;
     MapPolylineNodeOpenGLExtruded *m_polylinenode = nullptr;
 };
+#endif // QT_CONFIG(opengl)
 
 QT_END_NAMESPACE
 
--- a/qtlocation/src/location/declarativemaps/qdeclarativepolygonmapitem.cpp
+++ b/qtlocation/src/location/declarativemaps/qdeclarativepolygonmapitem.cpp
@@ -334,6 +334,7 @@ void QGeoMapPolygonGeometry::updateScree
         this->translate(QPointF(strokeWidth, strokeWidth));
 }
 
+#if QT_CONFIG(opengl)
 QGeoMapPolygonGeometryOpenGL::QGeoMapPolygonGeometryOpenGL(){
 }
 
@@ -344,6 +345,7 @@ void QGeoMapPolygonGeometryOpenGL::updat
         geopath.append(QWebMercator::mercatorToCoord(c));
     updateSourcePoints(map, geopath);
 }
+#endif
 
 // wrapPath always preserves the geometry
 // This one handles holes
@@ -452,6 +454,7 @@ static void cutPathEars(const QList<QDou
         screenIndices << quint32(i);
 }
 
+#if QT_CONFIG(opengl)
 /*!
     \internal
 */
@@ -594,7 +597,7 @@ void QGeoMapPolygonGeometryOpenGL::updat
     sourceBounds_.setWidth(brect.width());
     sourceBounds_.setHeight(brect.height());
 }
-
+#endif // QT_CONFIG(opengl)
 /*
  * QDeclarativePolygonMapItem Private Implementations
  */
@@ -603,8 +606,9 @@ QDeclarativePolygonMapItemPrivate::~QDec
 
 QDeclarativePolygonMapItemPrivateCPU::~QDeclarativePolygonMapItemPrivateCPU() {}
 
+#if QT_CONFIG(opengl)
 QDeclarativePolygonMapItemPrivateOpenGL::~QDeclarativePolygonMapItemPrivateOpenGL() {}
-
+#endif
 /*
  * QDeclarativePolygonMapItem Implementation
  */
@@ -689,9 +693,17 @@ void QDeclarativePolygonMapItem::setBack
     if (b == m_backend)
         return;
     m_backend = b;
-    QScopedPointer<QDeclarativePolygonMapItemPrivate> d((m_backend == Software)
-                                                        ? static_cast<QDeclarativePolygonMapItemPrivate *>(new QDeclarativePolygonMapItemPrivateCPU(*this))
-                                                        : static_cast<QDeclarativePolygonMapItemPrivate * >(new QDeclarativePolygonMapItemPrivateOpenGL(*this)));
+    QScopedPointer<QDeclarativePolygonMapItemPrivate> d(
+            (m_backend == Software) ? static_cast<QDeclarativePolygonMapItemPrivate *>(
+                    new QDeclarativePolygonMapItemPrivateCPU(*this))
+#if QT_CONFIG(opengl)
+                                    : static_cast<QDeclarativePolygonMapItemPrivate *>(
+                                            new QDeclarativePolygonMapItemPrivateOpenGL(*this)));
+#else
+                                    : nullptr);
+    qFatal("Requested non software rendering backend, but source code is compiled wihtout opengl "
+           "support");
+#endif
     m_d.swap(d);
     m_d->onGeoGeometryChanged();
     emit backendChanged();
@@ -898,6 +910,7 @@ void QDeclarativePolygonMapItem::geometr
 
 //////////////////////////////////////////////////////////////////////
 
+#if QT_CONFIG(opengl)
 QSGMaterialShader *MapPolygonMaterial::createShader() const
 {
     return new MapPolygonShader();
@@ -916,6 +929,7 @@ QSGMaterialType *MapPolygonMaterial::typ
     static QSGMaterialType type;
     return &type;
 }
+#endif
 
 MapPolygonNode::MapPolygonNode() :
     border_(new MapPolylineNode()),
@@ -967,6 +981,7 @@ void MapPolygonNode::update(const QColor
     }
 }
 
+#if QT_CONFIG(opengl)
 MapPolygonNodeGL::MapPolygonNodeGL() :
     //fill_material_(this),
     fill_material_(),
@@ -1052,5 +1067,5 @@ void MapPolygonShader::updateState(const
     program()->setUniformValue(m_center_lowpart_id, vecCenter_lowpart);
     program()->setUniformValue(m_wrapOffset_id, float(newMaterial->wrapOffset()));
 }
-
+#endif // QT_CONFIG(opengl)
 QT_END_NAMESPACE
--- a/qtlocation/src/location/declarativemaps/qdeclarativepolygonmapitem_p_p.h
+++ b/qtlocation/src/location/declarativemaps/qdeclarativepolygonmapitem_p_p.h
@@ -89,6 +89,7 @@ protected:
     bool assumeSimple_;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QGeoMapPolygonGeometryOpenGL : public QGeoMapItemGeometry
 {
 public:
@@ -197,6 +198,7 @@ private:
     int m_color_id;
     int m_wrapOffset_id;
 };
+#endif // QT_CONFIG(opengl)
 
 class Q_LOCATION_PRIVATE_EXPORT MapPolygonMaterial : public QSGFlatColorMaterial
 {
@@ -269,6 +271,7 @@ private:
     QSGGeometry geometry_;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT MapPolygonNodeGL : public MapItemGeometryNode
 {
 
@@ -284,6 +287,7 @@ public:
     MapPolygonMaterial fill_material_;
     QSGGeometry geometry_;
 };
+#endif // QT_CONFIG(opengl)
 
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolygonMapItemPrivate
 {
@@ -479,6 +483,7 @@ public:
     MapPolygonNode *m_node = nullptr;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolygonMapItemPrivateOpenGL: public QDeclarativePolygonMapItemPrivate
 {
 public:
@@ -662,6 +667,7 @@ public:
     MapPolygonNodeGL *m_node = nullptr;
     MapPolylineNodeOpenGLExtruded *m_polylinenode = nullptr;
 };
+#endif // QT_CONFIG(opengl)
 
 QT_END_NAMESPACE
 
--- a/qtlocation/src/location/declarativemaps/qdeclarativepolylinemapitem.cpp
+++ b/qtlocation/src/location/declarativemaps/qdeclarativepolylinemapitem.cpp
@@ -769,6 +769,7 @@ bool QGeoMapPolylineGeometry::contains(c
     return false;
 }
 
+#if QT_CONFIG(opengl)
 void QGeoMapPolylineGeometryOpenGL::updateSourcePoints(const QGeoMap &map, const QGeoPolygon &poly)
 {
     if (!sourceDirty_)
@@ -921,6 +922,7 @@ void QGeoMapPolylineGeometryOpenGL::upda
     sourceBounds_.setWidth(brect.width() + strokeWidth);
     sourceBounds_.setHeight(brect.height() + strokeWidth);
 }
+#endif // QT_CONFIG(opengl)
 
 /*
  * QDeclarativePolygonMapItem Private Implementations
@@ -931,9 +933,11 @@ QDeclarativePolylineMapItemPrivate::~QDe
 
 QDeclarativePolylineMapItemPrivateCPU::~QDeclarativePolylineMapItemPrivateCPU() {}
 
+#if QT_CONFIG(opengl)
 QDeclarativePolylineMapItemPrivateOpenGLLineStrip::~QDeclarativePolylineMapItemPrivateOpenGLLineStrip() {}
 
 QDeclarativePolylineMapItemPrivateOpenGLExtruded::~QDeclarativePolylineMapItemPrivateOpenGLExtruded() {}
+#endif
 
 /*
  * QDeclarativePolygonMapItem Implementation
@@ -941,10 +945,12 @@ QDeclarativePolylineMapItemPrivateOpenGL
 
 struct PolylineBackendSelector
 {
+#if QT_CONFIG(opengl)
     PolylineBackendSelector()
     {
         backend = (qgetenv("QTLOCATION_OPENGL_ITEMS").toInt()) ? QDeclarativePolylineMapItem::OpenGLExtruded : QDeclarativePolylineMapItem::Software;
     }
+#endif
     QDeclarativePolylineMapItem::Backend backend = QDeclarativePolylineMapItem::Software;
 };
 
@@ -1236,11 +1242,22 @@ void QDeclarativePolylineMapItem::setBac
     if (b == m_backend)
         return;
     m_backend = b;
-    QScopedPointer<QDeclarativePolylineMapItemPrivate> d((m_backend == Software)
-                                                        ? static_cast<QDeclarativePolylineMapItemPrivate *>(new QDeclarativePolylineMapItemPrivateCPU(*this))
-                                                        : ((m_backend == OpenGLExtruded)
-                                                           ? static_cast<QDeclarativePolylineMapItemPrivate * >(new QDeclarativePolylineMapItemPrivateOpenGLExtruded(*this))
-                                                           : static_cast<QDeclarativePolylineMapItemPrivate * >(new QDeclarativePolylineMapItemPrivateOpenGLLineStrip(*this))));
+    QScopedPointer<QDeclarativePolylineMapItemPrivate> d(
+            (m_backend == Software)
+                    ? static_cast<QDeclarativePolylineMapItemPrivate *>(
+                            new QDeclarativePolylineMapItemPrivateCPU(*this))
+#if QT_CONFIG(opengl)
+                    : ((m_backend == OpenGLExtruded)
+                               ? static_cast<QDeclarativePolylineMapItemPrivate *>(
+                                       new QDeclarativePolylineMapItemPrivateOpenGLExtruded(*this))
+                               : static_cast<QDeclarativePolylineMapItemPrivate *>(
+                                       new QDeclarativePolylineMapItemPrivateOpenGLLineStrip(
+                                               *this))));
+#else
+                    : nullptr);
+    qFatal("Requested non software rendering backend, but source code is compiled wihtout opengl "
+           "support");
+#endif
     m_d.swap(d);
     m_d->onGeoGeometryChanged();
     emit backendChanged();
@@ -1477,6 +1494,7 @@ void MapPolylineNode::update(const QColo
     }
 }
 
+#if QT_CONFIG(opengl)
 MapPolylineNodeOpenGLLineStrip::MapPolylineNodeOpenGLLineStrip()
 : geometry_(QSGGeometry::defaultAttributes_Point2D(), 0)
 {
@@ -2080,5 +2098,6 @@ unsigned int QGeoMapItemLODGeometry::zoo
         return res;
     return res + 1; // give more resolution when closing in
 }
+#endif // QT_CONFIG(opengl)
 
 QT_END_NAMESPACE
--- a/qtlocation/src/location/declarativemaps/qdeclarativepolylinemapitem_p.h
+++ b/qtlocation/src/location/declarativemaps/qdeclarativepolylinemapitem_p.h
@@ -97,8 +97,10 @@ class Q_LOCATION_PRIVATE_EXPORT QDeclara
 public:
     enum Backend {
         Software = 0,
-        OpenGLLineStrip = 1,
+#if QT_CONFIG(opengl)
+	OpenGLLineStrip = 1,
         OpenGLExtruded = 2,
+#endif
     };
 
     explicit QDeclarativePolylineMapItem(QQuickItem *parent = 0);
--- a/qtlocation/src/location/declarativemaps/qdeclarativepolylinemapitem_p_p.h
+++ b/qtlocation/src/location/declarativemaps/qdeclarativepolylinemapitem_p_p.h
@@ -213,6 +213,7 @@ protected:
     QSGGeometry geometry_;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QGeoMapItemLODGeometry
 {
 public:
@@ -566,6 +567,7 @@ protected:
     MapPolylineMaterialExtruded fill_material_;
     QSGGeometry m_geometryTriangulating;
 };
+#endif // QT_CONFIG(opengl)
 
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolylineMapItemPrivate
 {
@@ -720,6 +722,7 @@ public:
     MapPolylineNode *m_node = nullptr;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolylineMapItemPrivateOpenGLLineStrip: public QDeclarativePolylineMapItemPrivate
 {
 public:
@@ -884,7 +887,7 @@ public:
 
     MapPolylineNodeOpenGLExtruded *m_nodeTri = nullptr;
 };
-
+#endif // QT_CONFIG(opengl)
 QT_END_NAMESPACE
 
 #endif // QDECLARATIVEPOLYLINEMAPITEM_P_P_H
--- a/qtlocation/src/location/declarativemaps/qdeclarativerectanglemapitem.cpp
+++ b/qtlocation/src/location/declarativemaps/qdeclarativerectanglemapitem.cpp
@@ -185,9 +185,18 @@ void QDeclarativeRectangleMapItem::setBa
     if (b == m_backend)
         return;
     m_backend = b;
-    QScopedPointer<QDeclarativeRectangleMapItemPrivate> d((m_backend == Software)
-                                                        ? static_cast<QDeclarativeRectangleMapItemPrivate *>(new QDeclarativeRectangleMapItemPrivateCPU(*this))
-                                                        : static_cast<QDeclarativeRectangleMapItemPrivate * >(new QDeclarativeRectangleMapItemPrivateOpenGL(*this)));
+    QScopedPointer<QDeclarativeRectangleMapItemPrivate> d(
+            (m_backend == Software) ? static_cast<QDeclarativeRectangleMapItemPrivate *>(
+                    new QDeclarativeRectangleMapItemPrivateCPU(*this))
+#if QT_CONFIG(opengl)
+                                    : static_cast<QDeclarativeRectangleMapItemPrivate *>(
+                                            new QDeclarativeRectangleMapItemPrivateOpenGL(*this)));
+#else
+                                    : nullptr);
+    qFatal("Requested non software rendering backend, but source code is compiled wihtout opengl "
+           "support");
+#endif
+
     m_d.swap(d);
     m_d->onGeoGeometryChanged();
     emit backendChanged();
@@ -397,6 +406,8 @@ QDeclarativeRectangleMapItemPrivate::~QD
 
 QDeclarativeRectangleMapItemPrivateCPU::~QDeclarativeRectangleMapItemPrivateCPU() {}
 
+#if QT_CONFIG(opengl)
 QDeclarativeRectangleMapItemPrivateOpenGL::~QDeclarativeRectangleMapItemPrivateOpenGL() {}
+#endif
 
 QT_END_NAMESPACE
--- a/qtlocation/src/location/declarativemaps/qdeclarativerectanglemapitem_p_p.h
+++ b/qtlocation/src/location/declarativemaps/qdeclarativerectanglemapitem_p_p.h
@@ -244,6 +244,7 @@ public:
     MapPolygonNode *m_node = nullptr;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativeRectangleMapItemPrivateOpenGL: public QDeclarativeRectangleMapItemPrivate
 {
 public:
@@ -410,6 +411,7 @@ public:
     MapPolygonNodeGL *m_node = nullptr;
     MapPolylineNodeOpenGLExtruded *m_polylinenode = nullptr;
 };
+#endif // QT_CONFIG(opengl)
 
 QT_END_NAMESPACE
 
--- a/qtlocation/src/location/location.pro
+++ b/qtlocation/src/location/location.pro
@@ -39,7 +39,14 @@ include(maps/maps.pri)
 include(places/places.pri)
 include(declarativemaps/declarativemaps.pri)
 include(declarativeplaces/declarativeplaces.pri)
-qtConfig(location-labs-plugin):include(labs/labs.pri)
+qtConfig(location-labs-plugin) {
+   include(labs/labs.pri)
+} else {
+  # FIXME: this should be moved out of plugin source code, geojson is referenced from other places
+  # within codebase,however compilation of location-labs-plugin is optional
+    PRIVATE_HEADERS += labs/qgeojson_p.h
+      SOURCES += labs/qgeojson.cpp
+}
 
 HEADERS += $$PUBLIC_HEADERS $$PRIVATE_HEADERS
 
--- a/qtlocation/src/plugins/geoservices/itemsoverlay/qgeomapitemsoverlay.cpp
+++ b/qtlocation/src/plugins/geoservices/itemsoverlay/qgeomapitemsoverlay.cpp
@@ -103,6 +103,7 @@ QGeoMap::Capabilities QGeoMapItemsOverla
 bool QGeoMapItemsOverlay::createMapObjectImplementation(QGeoMapObject *obj)
 {
 #ifndef LOCATIONLABS
+    Q_UNUSED(obj);
     return false;
 #else
     Q_D(QGeoMapItemsOverlay);
@@ -132,7 +133,9 @@ QSGNode *QGeoMapItemsOverlay::updateScen
 
 void QGeoMapItemsOverlay::removeMapObject(QGeoMapObject *obj)
 {
-#ifdef LOCATIONLABS
+#ifndef LOCATIONLABS
+    Q_UNUSED(obj);
+#else
     Q_D(QGeoMapItemsOverlay);
     d->removeMapObject(obj);
 #endif
@@ -169,7 +172,11 @@ QRectF QGeoMapItemsOverlayPrivate::visib
 QGeoMapItemsOverlayPrivate::QGeoMapItemsOverlayPrivate(QGeoMappingManagerEngineItemsOverlay *engine, QGeoMapItemsOverlay *map)
     : QGeoMapPrivate(engine, new QGeoProjectionWebMercator)
 {
+#ifndef LOCATIONLABS
+    Q_UNUSED(map);
+#else
     m_qsgSupport.m_map = map;
+#endif
 }
 
 QGeoMapItemsOverlayPrivate::~QGeoMapItemsOverlayPrivate()
